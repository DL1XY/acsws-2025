// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v3.1.3
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "SYSTEMErrC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "cstring"

#if !defined (__ACE_INLINE__)
#include "SYSTEMErrC.inl"
#endif /* !defined INLINE */
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
        "SYSTEMErrEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
        "SYSTEMErrEx")
{
}

SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx (const ::SYSTEMErr::SYSTEMErrEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SYSTEMErrEx&
SYSTEMErr::SYSTEMErrEx::operator= (const ::SYSTEMErr::SYSTEMErrEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SYSTEMErrEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SYSTEMErrEx *_tao_tmp_pointer =
    static_cast<SYSTEMErrEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SYSTEMErrEx *
SYSTEMErr::SYSTEMErrEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SYSTEMErrEx *> (_tao_excp);
}

const SYSTEMErr::SYSTEMErrEx *
SYSTEMErr::SYSTEMErrEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SYSTEMErrEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SYSTEMErrEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SYSTEMErrEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SYSTEMErrEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::SYSTEMErrEx (*this), nullptr);
  return result;
}

void SYSTEMErr::SYSTEMErrEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::SYSTEMErrEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SYSTEMErrEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SYSTEMErrEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_SYSTEMErrEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SYSTEMErrEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SYSTEMErrEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
  "SYSTEMErrEx",
  _tao_fields_SYSTEMErr_SYSTEMErrEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SYSTEMErrEx =
    &_tao_tc_SYSTEMErr_SYSTEMErrEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
        "AlreadyInAutomaticEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
        "AlreadyInAutomaticEx")
{
}

SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx (const ::SYSTEMErr::AlreadyInAutomaticEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::AlreadyInAutomaticEx&
SYSTEMErr::AlreadyInAutomaticEx::operator= (const ::SYSTEMErr::AlreadyInAutomaticEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyInAutomaticEx *_tao_tmp_pointer =
    static_cast<AlreadyInAutomaticEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::AlreadyInAutomaticEx *
SYSTEMErr::AlreadyInAutomaticEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<AlreadyInAutomaticEx *> (_tao_excp);
}

const SYSTEMErr::AlreadyInAutomaticEx *
SYSTEMErr::AlreadyInAutomaticEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const AlreadyInAutomaticEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::AlreadyInAutomaticEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::AlreadyInAutomaticEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::AlreadyInAutomaticEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::AlreadyInAutomaticEx (*this), nullptr);
  return result;
}

void SYSTEMErr::AlreadyInAutomaticEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::AlreadyInAutomaticEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_AlreadyInAutomaticEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_AlreadyInAutomaticEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_AlreadyInAutomaticEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
  "AlreadyInAutomaticEx",
  _tao_fields_SYSTEMErr_AlreadyInAutomaticEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_AlreadyInAutomaticEx =
    &_tao_tc_SYSTEMErr_AlreadyInAutomaticEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
        "PositionOutOfLimitsEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
        "PositionOutOfLimitsEx")
{
}

SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx (const ::SYSTEMErr::PositionOutOfLimitsEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::PositionOutOfLimitsEx&
SYSTEMErr::PositionOutOfLimitsEx::operator= (const ::SYSTEMErr::PositionOutOfLimitsEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor (void *_tao_void_pointer)
{
  PositionOutOfLimitsEx *_tao_tmp_pointer =
    static_cast<PositionOutOfLimitsEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::PositionOutOfLimitsEx *
SYSTEMErr::PositionOutOfLimitsEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PositionOutOfLimitsEx *> (_tao_excp);
}

const SYSTEMErr::PositionOutOfLimitsEx *
SYSTEMErr::PositionOutOfLimitsEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PositionOutOfLimitsEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::PositionOutOfLimitsEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::PositionOutOfLimitsEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::PositionOutOfLimitsEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::PositionOutOfLimitsEx (*this), nullptr);
  return result;
}

void SYSTEMErr::PositionOutOfLimitsEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::PositionOutOfLimitsEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_PositionOutOfLimitsEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_PositionOutOfLimitsEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_PositionOutOfLimitsEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
  "PositionOutOfLimitsEx",
  _tao_fields_SYSTEMErr_PositionOutOfLimitsEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_PositionOutOfLimitsEx =
    &_tao_tc_SYSTEMErr_PositionOutOfLimitsEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
        "ProposalNotYetReadyEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
        "ProposalNotYetReadyEx")
{
}

SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx (const ::SYSTEMErr::ProposalNotYetReadyEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::ProposalNotYetReadyEx&
SYSTEMErr::ProposalNotYetReadyEx::operator= (const ::SYSTEMErr::ProposalNotYetReadyEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor (void *_tao_void_pointer)
{
  ProposalNotYetReadyEx *_tao_tmp_pointer =
    static_cast<ProposalNotYetReadyEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::ProposalNotYetReadyEx *
SYSTEMErr::ProposalNotYetReadyEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ProposalNotYetReadyEx *> (_tao_excp);
}

const SYSTEMErr::ProposalNotYetReadyEx *
SYSTEMErr::ProposalNotYetReadyEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ProposalNotYetReadyEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::ProposalNotYetReadyEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::ProposalNotYetReadyEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::ProposalNotYetReadyEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::ProposalNotYetReadyEx (*this), nullptr);
  return result;
}

void SYSTEMErr::ProposalNotYetReadyEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::ProposalNotYetReadyEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_ProposalNotYetReadyEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_ProposalNotYetReadyEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_ProposalNotYetReadyEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
  "ProposalNotYetReadyEx",
  _tao_fields_SYSTEMErr_ProposalNotYetReadyEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_ProposalNotYetReadyEx =
    &_tao_tc_SYSTEMErr_ProposalNotYetReadyEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
        "InvalidProposalStatusTransitionEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
        "InvalidProposalStatusTransitionEx")
{
}

SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx (const ::SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::InvalidProposalStatusTransitionEx&
SYSTEMErr::InvalidProposalStatusTransitionEx::operator= (const ::SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidProposalStatusTransitionEx *_tao_tmp_pointer =
    static_cast<InvalidProposalStatusTransitionEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::InvalidProposalStatusTransitionEx *
SYSTEMErr::InvalidProposalStatusTransitionEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidProposalStatusTransitionEx *> (_tao_excp);
}

const SYSTEMErr::InvalidProposalStatusTransitionEx *
SYSTEMErr::InvalidProposalStatusTransitionEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidProposalStatusTransitionEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::InvalidProposalStatusTransitionEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::InvalidProposalStatusTransitionEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::InvalidProposalStatusTransitionEx (*this), nullptr);
  return result;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_InvalidProposalStatusTransitionEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_InvalidProposalStatusTransitionEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_InvalidProposalStatusTransitionEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
  "InvalidProposalStatusTransitionEx",
  _tao_fields_SYSTEMErr_InvalidProposalStatusTransitionEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_InvalidProposalStatusTransitionEx =
    &_tao_tc_SYSTEMErr_InvalidProposalStatusTransitionEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
        "ImageAlreadyStoredEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
        "ImageAlreadyStoredEx")
{
}

SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx (const ::SYSTEMErr::ImageAlreadyStoredEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::ImageAlreadyStoredEx&
SYSTEMErr::ImageAlreadyStoredEx::operator= (const ::SYSTEMErr::ImageAlreadyStoredEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor (void *_tao_void_pointer)
{
  ImageAlreadyStoredEx *_tao_tmp_pointer =
    static_cast<ImageAlreadyStoredEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::ImageAlreadyStoredEx *
SYSTEMErr::ImageAlreadyStoredEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ImageAlreadyStoredEx *> (_tao_excp);
}

const SYSTEMErr::ImageAlreadyStoredEx *
SYSTEMErr::ImageAlreadyStoredEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ImageAlreadyStoredEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::ImageAlreadyStoredEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::ImageAlreadyStoredEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::ImageAlreadyStoredEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::ImageAlreadyStoredEx (*this), nullptr);
  return result;
}

void SYSTEMErr::ImageAlreadyStoredEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::ImageAlreadyStoredEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_ImageAlreadyStoredEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_ImageAlreadyStoredEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_ImageAlreadyStoredEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
  "ImageAlreadyStoredEx",
  _tao_fields_SYSTEMErr_ImageAlreadyStoredEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_ImageAlreadyStoredEx =
    &_tao_tc_SYSTEMErr_ImageAlreadyStoredEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::CameraIsOffEx::CameraIsOffEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
        "CameraIsOffEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::CameraIsOffEx::CameraIsOffEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
        "CameraIsOffEx")
{
}

SYSTEMErr::CameraIsOffEx::CameraIsOffEx (const ::SYSTEMErr::CameraIsOffEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::CameraIsOffEx&
SYSTEMErr::CameraIsOffEx::operator= (const ::SYSTEMErr::CameraIsOffEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::CameraIsOffEx::_tao_any_destructor (void *_tao_void_pointer)
{
  CameraIsOffEx *_tao_tmp_pointer =
    static_cast<CameraIsOffEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::CameraIsOffEx *
SYSTEMErr::CameraIsOffEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CameraIsOffEx *> (_tao_excp);
}

const SYSTEMErr::CameraIsOffEx *
SYSTEMErr::CameraIsOffEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CameraIsOffEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::CameraIsOffEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::CameraIsOffEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::CameraIsOffEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::CameraIsOffEx (*this), nullptr);
  return result;
}

void SYSTEMErr::CameraIsOffEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::CameraIsOffEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::CameraIsOffEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::CameraIsOffEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_CameraIsOffEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_CameraIsOffEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_CameraIsOffEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
  "CameraIsOffEx",
  _tao_fields_SYSTEMErr_CameraIsOffEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_CameraIsOffEx =
    &_tao_tc_SYSTEMErr_CameraIsOffEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
        "SchedulerAlreadyRunningEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
        "SchedulerAlreadyRunningEx")
{
}

SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx (const ::SYSTEMErr::SchedulerAlreadyRunningEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SchedulerAlreadyRunningEx&
SYSTEMErr::SchedulerAlreadyRunningEx::operator= (const ::SYSTEMErr::SchedulerAlreadyRunningEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SchedulerAlreadyRunningEx *_tao_tmp_pointer =
    static_cast<SchedulerAlreadyRunningEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SchedulerAlreadyRunningEx *
SYSTEMErr::SchedulerAlreadyRunningEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SchedulerAlreadyRunningEx *> (_tao_excp);
}

const SYSTEMErr::SchedulerAlreadyRunningEx *
SYSTEMErr::SchedulerAlreadyRunningEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SchedulerAlreadyRunningEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SchedulerAlreadyRunningEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SchedulerAlreadyRunningEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SchedulerAlreadyRunningEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::SchedulerAlreadyRunningEx (*this), nullptr);
  return result;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SchedulerAlreadyRunningEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_SchedulerAlreadyRunningEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SchedulerAlreadyRunningEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SchedulerAlreadyRunningEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
  "SchedulerAlreadyRunningEx",
  _tao_fields_SYSTEMErr_SchedulerAlreadyRunningEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SchedulerAlreadyRunningEx =
    &_tao_tc_SYSTEMErr_SchedulerAlreadyRunningEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
        "SchedulerAlreadyStoppedEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
        "SchedulerAlreadyStoppedEx")
{
}

SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx (const ::SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SchedulerAlreadyStoppedEx&
SYSTEMErr::SchedulerAlreadyStoppedEx::operator= (const ::SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SchedulerAlreadyStoppedEx *_tao_tmp_pointer =
    static_cast<SchedulerAlreadyStoppedEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SchedulerAlreadyStoppedEx *
SYSTEMErr::SchedulerAlreadyStoppedEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SchedulerAlreadyStoppedEx *> (_tao_excp);
}

const SYSTEMErr::SchedulerAlreadyStoppedEx *
SYSTEMErr::SchedulerAlreadyStoppedEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SchedulerAlreadyStoppedEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SchedulerAlreadyStoppedEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SchedulerAlreadyStoppedEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::SchedulerAlreadyStoppedEx (*this), nullptr);
  return result;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_SchedulerAlreadyStoppedEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SchedulerAlreadyStoppedEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SchedulerAlreadyStoppedEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
  "SchedulerAlreadyStoppedEx",
  _tao_fields_SYSTEMErr_SchedulerAlreadyStoppedEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SchedulerAlreadyStoppedEx =
    &_tao_tc_SYSTEMErr_SchedulerAlreadyStoppedEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
        "NoProposalExecutingEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
        "NoProposalExecutingEx")
{
}

SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx (const ::SYSTEMErr::NoProposalExecutingEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::NoProposalExecutingEx&
SYSTEMErr::NoProposalExecutingEx::operator= (const ::SYSTEMErr::NoProposalExecutingEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor (void *_tao_void_pointer)
{
  NoProposalExecutingEx *_tao_tmp_pointer =
    static_cast<NoProposalExecutingEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::NoProposalExecutingEx *
SYSTEMErr::NoProposalExecutingEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NoProposalExecutingEx *> (_tao_excp);
}

const SYSTEMErr::NoProposalExecutingEx *
SYSTEMErr::NoProposalExecutingEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NoProposalExecutingEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::NoProposalExecutingEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::NoProposalExecutingEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::NoProposalExecutingEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::NoProposalExecutingEx (*this), nullptr);
  return result;
}

void SYSTEMErr::NoProposalExecutingEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::NoProposalExecutingEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::NoProposalExecutingEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::NoProposalExecutingEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_NoProposalExecutingEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_NoProposalExecutingEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_NoProposalExecutingEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
  "NoProposalExecutingEx",
  _tao_fields_SYSTEMErr_NoProposalExecutingEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_NoProposalExecutingEx =
    &_tao_tc_SYSTEMErr_NoProposalExecutingEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
        "SystemInAutoModeEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
        "SystemInAutoModeEx")
{
}

SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx (const ::SYSTEMErr::SystemInAutoModeEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SystemInAutoModeEx&
SYSTEMErr::SystemInAutoModeEx::operator= (const ::SYSTEMErr::SystemInAutoModeEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SystemInAutoModeEx *_tao_tmp_pointer =
    static_cast<SystemInAutoModeEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SystemInAutoModeEx *
SYSTEMErr::SystemInAutoModeEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SystemInAutoModeEx *> (_tao_excp);
}

const SYSTEMErr::SystemInAutoModeEx *
SYSTEMErr::SystemInAutoModeEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SystemInAutoModeEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SystemInAutoModeEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SystemInAutoModeEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SystemInAutoModeEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::SystemInAutoModeEx (*this), nullptr);
  return result;
}

void SYSTEMErr::SystemInAutoModeEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::SystemInAutoModeEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SystemInAutoModeEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SystemInAutoModeEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_SystemInAutoModeEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SystemInAutoModeEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SystemInAutoModeEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
  "SystemInAutoModeEx",
  _tao_fields_SYSTEMErr_SystemInAutoModeEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SystemInAutoModeEx =
    &_tao_tc_SYSTEMErr_SystemInAutoModeEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
        "CannotOpenDeviceEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
        "CannotOpenDeviceEx")
{
}

SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx (const ::SYSTEMErr::CannotOpenDeviceEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::CannotOpenDeviceEx&
SYSTEMErr::CannotOpenDeviceEx::operator= (const ::SYSTEMErr::CannotOpenDeviceEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor (void *_tao_void_pointer)
{
  CannotOpenDeviceEx *_tao_tmp_pointer =
    static_cast<CannotOpenDeviceEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::CannotOpenDeviceEx *
SYSTEMErr::CannotOpenDeviceEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CannotOpenDeviceEx *> (_tao_excp);
}

const SYSTEMErr::CannotOpenDeviceEx *
SYSTEMErr::CannotOpenDeviceEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CannotOpenDeviceEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::CannotOpenDeviceEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::CannotOpenDeviceEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::CannotOpenDeviceEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::CannotOpenDeviceEx (*this), nullptr);
  return result;
}

void SYSTEMErr::CannotOpenDeviceEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::CannotOpenDeviceEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_CannotOpenDeviceEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_CannotOpenDeviceEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_CannotOpenDeviceEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
  "CannotOpenDeviceEx",
  _tao_fields_SYSTEMErr_CannotOpenDeviceEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_CannotOpenDeviceEx =
    &_tao_tc_SYSTEMErr_CannotOpenDeviceEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::ProposalDoesNotExistEx::ProposalDoesNotExistEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalDoesNotExistEx:1.0",
        "ProposalDoesNotExistEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::ProposalDoesNotExistEx::ProposalDoesNotExistEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalDoesNotExistEx:1.0",
        "ProposalDoesNotExistEx")
{
}

SYSTEMErr::ProposalDoesNotExistEx::ProposalDoesNotExistEx (const ::SYSTEMErr::ProposalDoesNotExistEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::ProposalDoesNotExistEx&
SYSTEMErr::ProposalDoesNotExistEx::operator= (const ::SYSTEMErr::ProposalDoesNotExistEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::ProposalDoesNotExistEx::_tao_any_destructor (void *_tao_void_pointer)
{
  ProposalDoesNotExistEx *_tao_tmp_pointer =
    static_cast<ProposalDoesNotExistEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::ProposalDoesNotExistEx *
SYSTEMErr::ProposalDoesNotExistEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ProposalDoesNotExistEx *> (_tao_excp);
}

const SYSTEMErr::ProposalDoesNotExistEx *
SYSTEMErr::ProposalDoesNotExistEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ProposalDoesNotExistEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::ProposalDoesNotExistEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::ProposalDoesNotExistEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::ProposalDoesNotExistEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::ProposalDoesNotExistEx (*this), nullptr);
  return result;
}

void SYSTEMErr::ProposalDoesNotExistEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::ProposalDoesNotExistEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::ProposalDoesNotExistEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::ProposalDoesNotExistEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_ProposalDoesNotExistEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_ProposalDoesNotExistEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_ProposalDoesNotExistEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/ProposalDoesNotExistEx:1.0",
  "ProposalDoesNotExistEx",
  _tao_fields_SYSTEMErr_ProposalDoesNotExistEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_ProposalDoesNotExistEx =
    &_tao_tc_SYSTEMErr_ProposalDoesNotExistEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



SYSTEMErr::TargetDoesNotExistEx::TargetDoesNotExistEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/TargetDoesNotExistEx:1.0",
        "TargetDoesNotExistEx")
{
  this->errorTrace = _tao_errorTrace;
}


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

SYSTEMErr::TargetDoesNotExistEx::TargetDoesNotExistEx ()
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/TargetDoesNotExistEx:1.0",
        "TargetDoesNotExistEx")
{
}

SYSTEMErr::TargetDoesNotExistEx::TargetDoesNotExistEx (const ::SYSTEMErr::TargetDoesNotExistEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::TargetDoesNotExistEx&
SYSTEMErr::TargetDoesNotExistEx::operator= (const ::SYSTEMErr::TargetDoesNotExistEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::TargetDoesNotExistEx::_tao_any_destructor (void *_tao_void_pointer)
{
  TargetDoesNotExistEx *_tao_tmp_pointer =
    static_cast<TargetDoesNotExistEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::TargetDoesNotExistEx *
SYSTEMErr::TargetDoesNotExistEx::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<TargetDoesNotExistEx *> (_tao_excp);
}

const SYSTEMErr::TargetDoesNotExistEx *
SYSTEMErr::TargetDoesNotExistEx::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const TargetDoesNotExistEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::TargetDoesNotExistEx::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::SYSTEMErr::TargetDoesNotExistEx, nullptr);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::TargetDoesNotExistEx::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::SYSTEMErr::TargetDoesNotExistEx (*this), nullptr);
  return result;
}

void SYSTEMErr::TargetDoesNotExistEx::_raise () const
{
  throw *this;
}

void SYSTEMErr::TargetDoesNotExistEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::TargetDoesNotExistEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::TargetDoesNotExistEx::_tao_type () const
{
  return ::SYSTEMErr::_tc_TargetDoesNotExistEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_TargetDoesNotExistEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_TargetDoesNotExistEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/TargetDoesNotExistEx:1.0",
  "TargetDoesNotExistEx",
  _tao_fields_SYSTEMErr_TargetDoesNotExistEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_TargetDoesNotExistEx =
    &_tao_tc_SYSTEMErr_TargetDoesNotExistEx;
}
// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::SYSTEMErrEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::insert_copy (
    _tao_any,
    SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
    SYSTEMErr::_tc_SYSTEMErrEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::SYSTEMErrEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::insert (
    _tao_any,
    SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
    SYSTEMErr::_tc_SYSTEMErrEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::SYSTEMErrEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::extract (
    _tao_any,
    SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
    SYSTEMErr::_tc_SYSTEMErrEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::AlreadyInAutomaticEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::insert_copy (
    _tao_any,
    SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
    SYSTEMErr::_tc_AlreadyInAutomaticEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::AlreadyInAutomaticEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::insert (
    _tao_any,
    SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
    SYSTEMErr::_tc_AlreadyInAutomaticEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::AlreadyInAutomaticEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::extract (
    _tao_any,
    SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
    SYSTEMErr::_tc_AlreadyInAutomaticEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::PositionOutOfLimitsEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::insert_copy (
    _tao_any,
    SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
    SYSTEMErr::_tc_PositionOutOfLimitsEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::PositionOutOfLimitsEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::insert (
    _tao_any,
    SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
    SYSTEMErr::_tc_PositionOutOfLimitsEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::PositionOutOfLimitsEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::extract (
    _tao_any,
    SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
    SYSTEMErr::_tc_PositionOutOfLimitsEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::ProposalNotYetReadyEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::insert_copy (
    _tao_any,
    SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalNotYetReadyEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::ProposalNotYetReadyEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::insert (
    _tao_any,
    SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalNotYetReadyEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::ProposalNotYetReadyEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::extract (
    _tao_any,
    SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalNotYetReadyEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::insert_copy (
    _tao_any,
    SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
    SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::InvalidProposalStatusTransitionEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::insert (
    _tao_any,
    SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
    SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::InvalidProposalStatusTransitionEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::extract (
    _tao_any,
    SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
    SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::ImageAlreadyStoredEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::insert_copy (
    _tao_any,
    SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
    SYSTEMErr::_tc_ImageAlreadyStoredEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::ImageAlreadyStoredEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::insert (
    _tao_any,
    SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
    SYSTEMErr::_tc_ImageAlreadyStoredEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::ImageAlreadyStoredEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::extract (
    _tao_any,
    SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
    SYSTEMErr::_tc_ImageAlreadyStoredEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::CameraIsOffEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::insert_copy (
    _tao_any,
    SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
    SYSTEMErr::_tc_CameraIsOffEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::CameraIsOffEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::insert (
    _tao_any,
    SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
    SYSTEMErr::_tc_CameraIsOffEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::CameraIsOffEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::extract (
    _tao_any,
    SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
    SYSTEMErr::_tc_CameraIsOffEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::SchedulerAlreadyRunningEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::insert_copy (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::SchedulerAlreadyRunningEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::insert (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::SchedulerAlreadyRunningEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::extract (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::insert_copy (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::SchedulerAlreadyStoppedEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::insert (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::SchedulerAlreadyStoppedEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::extract (
    _tao_any,
    SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
    SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::NoProposalExecutingEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::insert_copy (
    _tao_any,
    SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
    SYSTEMErr::_tc_NoProposalExecutingEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::NoProposalExecutingEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::insert (
    _tao_any,
    SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
    SYSTEMErr::_tc_NoProposalExecutingEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::NoProposalExecutingEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::extract (
    _tao_any,
    SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
    SYSTEMErr::_tc_NoProposalExecutingEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::SystemInAutoModeEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::insert_copy (
    _tao_any,
    SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
    SYSTEMErr::_tc_SystemInAutoModeEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::SystemInAutoModeEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::insert (
    _tao_any,
    SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
    SYSTEMErr::_tc_SystemInAutoModeEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::SystemInAutoModeEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::extract (
    _tao_any,
    SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
    SYSTEMErr::_tc_SystemInAutoModeEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::CannotOpenDeviceEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::insert_copy (
    _tao_any,
    SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
    SYSTEMErr::_tc_CannotOpenDeviceEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::CannotOpenDeviceEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::insert (
    _tao_any,
    SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
    SYSTEMErr::_tc_CannotOpenDeviceEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::CannotOpenDeviceEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::extract (
    _tao_any,
    SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
    SYSTEMErr::_tc_CannotOpenDeviceEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::ProposalDoesNotExistEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::ProposalDoesNotExistEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalDoesNotExistEx>::insert_copy (
    _tao_any,
    SYSTEMErr::ProposalDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalDoesNotExistEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::ProposalDoesNotExistEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalDoesNotExistEx>::insert (
    _tao_any,
    SYSTEMErr::ProposalDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalDoesNotExistEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::ProposalDoesNotExistEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalDoesNotExistEx>::extract (
    _tao_any,
    SYSTEMErr::ProposalDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_ProposalDoesNotExistEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::TargetDoesNotExistEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const SYSTEMErr::TargetDoesNotExistEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::TargetDoesNotExistEx>::insert_copy (
    _tao_any,
    SYSTEMErr::TargetDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_TargetDoesNotExistEx,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  SYSTEMErr::TargetDoesNotExistEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::TargetDoesNotExistEx>::insert (
    _tao_any,
    SYSTEMErr::TargetDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_TargetDoesNotExistEx,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const SYSTEMErr::TargetDoesNotExistEx *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<SYSTEMErr::TargetDoesNotExistEx>::extract (
    _tao_any,
    SYSTEMErr::TargetDoesNotExistEx::_tao_any_destructor,
    SYSTEMErr::_tc_TargetDoesNotExistEx,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SYSTEMErrEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SYSTEMErrEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::AlreadyInAutomaticEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::AlreadyInAutomaticEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::PositionOutOfLimitsEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::PositionOutOfLimitsEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::ProposalNotYetReadyEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::ProposalNotYetReadyEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::ImageAlreadyStoredEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::ImageAlreadyStoredEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::CameraIsOffEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::CameraIsOffEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SchedulerAlreadyRunningEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SchedulerAlreadyRunningEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::NoProposalExecutingEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::NoProposalExecutingEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SystemInAutoModeEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SystemInAutoModeEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::CannotOpenDeviceEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::CannotOpenDeviceEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::ProposalDoesNotExistEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::ProposalDoesNotExistEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /alma/ACS-2025APR/TAO/ACE_wrappers/build/linux/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::TargetDoesNotExistEx &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::TargetDoesNotExistEx &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



